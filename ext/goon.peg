# Grammar

Stmt <- (SPACE Expr EOL)+
      / (!EOL .)* EOL
          { gn_set_error(gn_global_context(), 1); }

Expr <- ID
          { gn_symbol_node(gn_global_context(), yytext) }
        ASSIGN Sum
          { gn_reduce(gn_global_context(), GN_AST_ASSIGN, 2) }
      / Sum

Sum <- Product (
         PLUS Product
           { gn_reduce(gn_global_context(), GN_AST_ADD, 2) }
       / MINUS Product
           { gn_reduce(gn_global_context(), GN_AST_SUBTRACT, 2) }
       )*

Product <- Logical (
             TIMES Logical
              { gn_reduce(gn_global_context(), GN_AST_MULTIPLY, 2) }
           / DIVIDED_BY Logical
              { gn_reduce(gn_global_context(), GN_AST_DIVIDE, 2) }
           )*

Logical <- Equality (
         AND Equality
           { gn_reduce(gn_global_context(), GN_AST_AND, 2) }
       / OR Equality
           { gn_reduce(gn_global_context(), GN_AST_OR, 2) }
       )*

Equality <- Value (
              EQUALS Value
                { gn_reduce(gn_global_context(), GN_AST_COMPARE, 2) }
            / DOES_NOT_EQUAL Value
                { gn_reduce(gn_global_context(), GN_AST_INVERSE_COMPARE, 2) }
            )*

Value <- NIL { gn_nil_node(gn_global_context()) }
       / NUMBER { gn_number_node(gn_global_context(), yytext) }
       / TRUE { gn_bool_node(gn_global_context(), 1) }
       / FALSE { gn_bool_node(gn_global_context(), 0) }
       / ID { gn_symbol_node(gn_global_context(), yytext) }
       / OPEN Expr CLOSE

# Lexemes

NIL <- 'nil' SPACE
NUMBER <- < [0-9]+ > SPACE
ID <- < [a-zA-Z_]+ > SPACE
TRUE <- 'true' SPACE
FALSE <- 'false' SPACE
ASSIGN <- '=' SPACE
PLUS <- '+' SPACE
MINUS <- '-' SPACE
TIMES <- '*' SPACE
DIVIDED_BY <- '/' SPACE
AND <- 'and' SPACE
OR <- 'or' SPACE
EQUALS <- '==' SPACE
DOES_NOT_EQUAL <- '!='
OPEN <- '(' SPACE
CLOSE <- ')' SPACE

SPACE <- [ \t]*
EOL <- '\n'
